Select * From [MooDPrimaryElement] Order By [creationDateTime] Desc
Select * From [MooDElementData] Order By [creationDateTime] Desc
Delete From [MooDPrimaryElement] Where [creationDateTime] = '2025-03-03 08:01:17.000'
Delete From [MooDElementData] Where [creationDateTime] = '2025-03-03 08:01:17.000'


--Superfast Obsidian Hexadecimal-Compatible MooD Data Smashing Algorithm (To Be Used In A Custom T-SQL Synchroniser Script)
--This is a safer version of the smash hash algorithm from a hexadecimal ID clash avoidance perspective, but you have to take a compute speed performance hit in order to benefit from this safety... This safer algorithm allows up to all characters to be possibly the same, thereby exponentially increasing the dimensionality, and making the probability of ID clashes so low, that it may only happen once again in the whole future of the rest of the time-space continuum!!! (The original algorithm which this one was extended from, was WITHOUT character more-than-double-duplicates, whereas this safer algorithm is WITH character more-than-double-duplicates)... Only use this safer hasher if you are utterly concerned by the posssibility of ID clashes in business critical hyper scale data usecases, otherwise you will unnecessarily slow down computation, sometimes unacceptably so)...
--Eventually, I plan to amend this approach, so that all the necessary hexadecimal hash IDs can be pre-generated in parallel, before element creation and field data ingestion, as this will provide probably very significant compute speed improvements.
--Please be aware, that the Hexadecimal ID hash technique in this algorithm is 'Near-Perfect', because it optimises the trade-off between uniform balancing of values via the maximum utilisation of value space, and the implementation of the most appropriate speediness of computation... Without any significant or necessary 'fudging' we can handle the reality that 32 character hexadecimal ID hashes require scaffolds with elements that don't fall neatly onto a single integer scale (ie_ they have non zero modulus 10 characteristics)... This is deemed therefore no longer a problem by the Vulcan authorities for now, because 4th age humanoids can simply implement my run-of-the-mill pixie science, in order to defeat the Borg when necessary...
--Now onto some Hobbit stats... I asked ChatGPT what the probability of ID clashing was with this safer algorithm as it stands currently... It calculated that ID clashes would happen every 1 in ~2.94Ã—10^39 generated IDs (on average across an insane amount of generated IDs of course)... This is a vanishingly small number, and more than sufficient to ensure expected behaviour in basically all small data (1 Million IDs), medium data (1 Billion IDs), big data (1 Trillion IDs), and hyper data (1 Quadrillion IDs) usecases...


--(Scaffolds)
Declare @Dynamic_SQL_Data_Intermediate_Variable_Alpha As Nvarchar(Max)
Set @Dynamic_SQL_Data_Intermediate_Variable_Alpha =
(
'Declare @Number_Seeds Table ([Number_Seed] NvarChar(1))
Insert Into @Number_Seeds ([Number_Seed])
Values (''0''), (''1''), (''2''), (''3''), (''4''), (''5''), (''6''), (''7''), (''8''), (''9'') ' +
Replace(dbo.Obsidian_Element_Index_Generator_Code_Parallel_Super_Fast(32), '@Index_Count', 32) --This algorithm can be found on my GitHub account in the same repository that you found this script in.
)

Declare @Obsidian_Index_Scaffold_Alpha Table ([Index] Int)
Insert Into @Obsidian_Index_Scaffold_Alpha ([Index])
Execute (@Dynamic_SQL_Data_Intermediate_Variable_Alpha)

Declare @Dynamic_SQL_Data_Intermediate_Variable_Beta As Nvarchar(Max)
Set @Dynamic_SQL_Data_Intermediate_Variable_Beta =
(
'Declare @Number_Seeds Table ([Number_Seed] NvarChar(1))
Insert Into @Number_Seeds ([Number_Seed])
Values (''0''), (''1''), (''2''), (''3''), (''4''), (''5''), (''6''), (''7''), (''8''), (''9'') ' +
Replace(dbo.Obsidian_Element_Index_Generator_Code_Parallel_Super_Fast(32), '@Index_Count', 16) --This algorithm can be found on my GitHub account in the same repository that you found this script in.
)

Declare @Obsidian_Index_Scaffold_Beta Table ([Index] Int)
Insert Into @Obsidian_Index_Scaffold_Beta ([Index])
Execute (@Dynamic_SQL_Data_Intermediate_Variable_Beta)


--(Elements)
--Delta Scaffold Join Hash...
Declare @Obsidian_Element_Index_Scaffold_Delta_Intermediate Table ([Order_Beta] Int, [Index] Nvarchar(4000))
Insert Into @Obsidian_Element_Index_Scaffold_Delta_Intermediate ([Order_Beta], [Index])
Select
	Row_Number() Over(Partition By A.[Index] Order By Crypt_Gen_Random(200) Asc) As [Order_Beta], --This should scramble the index series appropriately, when used in conjunction with storing an order for each scrambled row.
	B.[Index] As [Index] --Could adjust the dynamic function for generating index scaffolds so that we eliminate the minus 1 altogether, but seems unreasonable right now, given the speed impact is nugatory...
From @Obsidian_Index_Scaffold_Alpha A
Cross Join @Obsidian_Index_Scaffold_Beta B

Declare @Obsidian_Element_Index_Scaffold_Delta_Final Table (/*[Order] Int, */[Hexadecimal_Character] Nvarchar(4000))
Insert Into @Obsidian_Element_Index_Scaffold_Delta_Final (/*[Order], */[Hexadecimal_Character])
Select
	--Row_Number() Over(Order By [Configure_Your_Desired_Order_Logic_Here] Asc) As [Order],
	Cast(Replace(Replace(Replace(Replace(Replace(Replace(Cast(([Index] - 1) As Nvarchar(4000)), '10', 'A'), '11', 'B'), '12', 'C'), '13', 'D'), '14', 'E'), '15', 'F') As Nvarchar(4000)) As [Hexadecimal_Character] --Could adjust the dynamic function for generating index scaffolds so that we eliminate the minus 1 altogether, but seems unreasonable right now, given the speed impact is nugatory...
From @Obsidian_Element_Index_Scaffold_Delta_Intermediate
Where [Order_Beta] = 1

--Harmonise Half Partitions
Declare @Element_Hexadecimal_ID_Hash As Nvarchar(4000)
Set @Element_Hexadecimal_ID_Hash = (Select String_Agg(Cast([Hexadecimal_Character] As Nvarchar(4000)), '') As [Element_Integer_ID_Hash] From @Obsidian_Element_Index_Scaffold_Delta_Final) --Be careful, the hash values are joined in no particular order... This may impact associated development work... If it is causing an issue, you can easily force the order by using the [Order] column which is previously assigned (but commented out as an example) in the @Obsidian_Element_Index_Scaffold_Delta_Final table insert select statement(with the Rown_Number() function), by adding something here with this str_agg function like: Within Group (Order By [Order] Asc) to this line of sourcecode, in the appropriate manner...

--(Something Seemingly Banal, Will Probably Turn Out To Be the Critical Algorithmic Facet... No Doubt...)
Declare @Max_Element_cluId As Bigint
Set @Max_Element_cluId = (Select Max([cluId]) From [MooDPrimaryElement])

--PLEASE DON'T FORGET TO AMEND THESE INSERTED ROW VALUES BELOW APPROPRIATELY... YOU WILL NEED TO LOOK UP THE [parentId] (IF YOU ARE NOT CREATING THE PARENT ELEMENT HERE ITSELF) ON THE [MooDPrimaryElement] TABLE IN THE MOOD DATABASE; AND THE YOU WILL NEED TO LOOK UP THE [aliasId] FROM THE [MooDAlias] TABLE IN THE MOOD SQL SERVER DATABASE... THE REST OF THE COLUMNS SHOULD BE RATHER SELF-EXPLANATORY IN MY HUMBLE OPINION... (IF YOU ARE CREATING PARENT ELEMENTS {OR EVEN A TREE OF ELEMENTS, THEN MAKE SURE YOU PUT THE HIGHEST LEVEL OF THE TREE TOWARDS THE TOP OF THE INSERT ROWS, AND ORDER THE ROWS SO THAT ALL DESCENDENTS WILL ALWAYS COME AFTER THEIR PARENT ELEMENT ROW... THEN SIMPLY WHILE LOOP AROUND THE INSERT SET OF ROWS, ONE LEVEL OF THE ELEMENT HIERARCHY AT A TIME [SO THAT YOU CAN PRE-GENERATE THE APPROPRIATE HEXADECIMAL IDENTIFIERS]})... OH, AND PLESE DON'T FORGET TO INCREMENT THE CLUID IF YOU ARE SIMULTANEOUSLY INSERTING MULTIPLE ELEMENT ROWS (HE'S MISBEHAVING ENOUGH ALREADY, I'M SURE YOU'LL AGREE)...
Set Identity_Insert [MooDPrimaryElement] ON
Insert Into [MooDPrimaryElement] ([className], [id], [parentId], [aliasId], [ownerId], [name], [variantOfId], [lastModifiedDateTime], [creationDateTime], [flags], [cluId])
Values ('PRIM', @Element_Hexadecimal_ID_Hash, '3708862BD1CD47458E9B65CED5DB79B4', '03AFE16743A3455889C46D09A05D55F1', '786A4991EA7B11D1B4840020AFC894E9', ('Database_Edit_Test_' + Cast(Getdate() As Nvarchar(4000))), NULL, '2025-03-03 08:01:17.000', '2025-03-03 08:01:17.000', 0, (@Max_Element_cluId + 1))
Set Identity_Insert [MooDPrimaryElement] OFF


--THE FOLLOWING DATA FIELD TECHNIQUE MUST BE CARRIED FOR EACH APPROPRIATE FIELD ON A GIVEN PREVIOUSLY CREATED MOOD ELEMENT IN THIS SMASH ALGORITHM, BECAUSE OTHERWISE, THE ELEMENTS MAY BE UNEDITABLE IN MOOD BA AND MOOD MAE!!!... AS SUCH, IF YOU ARE INGESTING A LOT OF FIELD DATA, YOU PROBABLY WANT TO IMPLEMENT THE REST OF THIS ALGORITHM WITHIN A WHILE LOOP, WHICH WOULD LOOP AROUND EACH MOOD ELEMENT FIELD, INSTEAD OF WHAT I HAVE DONE HERE, WHICH IS SIMPLY COPY AND PASTE HAND-CRANKING, BECAUSE I AM APPARENTLY NOT YET RECEIVING PAYMENT FOR MY EFFORTS!!!
--(Datatime Field 0001)
--Delta Scaffold Join Hash...
Declare @Obsidian_Field_0001_Index_Scaffold_Delta_Intermediate Table ([Order_Beta] Int, [Index] Nvarchar(4000))
Insert Into @Obsidian_Field_0001_Index_Scaffold_Delta_Intermediate ([Order_Beta], [Index])
Select
	Row_Number() Over(Partition By A.[Index] Order By Crypt_Gen_Random(200) Asc) As [Order_Beta], --This should scramble the index series appropriately, when used in conjunction with storing an order for each scrambled row.
	B.[Index] As [Index] --Could adjust the dynamic function for generating index scaffolds so that we eliminate the minus 1 altogether, but seems unreasonable right now, given the speed impact is nugatory...
From @Obsidian_Index_Scaffold_Alpha A
Cross Join @Obsidian_Index_Scaffold_Beta B

Declare @Obsidian_Field_0001_Index_Scaffold_Delta_Final Table (/*[Order] Int, */[Hexadecimal_Character] Nvarchar(4000))
Insert Into @Obsidian_Field_0001_Index_Scaffold_Delta_Final (/*[Order], */[Hexadecimal_Character])
Select
	--Row_Number() Over(Order By [Configure_Your_Desired_Order_Logic_Here] Asc) As [Order],
	Cast(Replace(Replace(Replace(Replace(Replace(Replace(Cast(([Index] - 1) As Nvarchar(4000)), '10', 'A'), '11', 'B'), '12', 'C'), '13', 'D'), '14', 'E'), '15', 'F') As Nvarchar(4000)) As [Hexadecimal_Character] --Could adjust the dynamic function for generating index scaffolds so that we eliminate the minus 1 altogether, but seems unreasonable right now, given the speed impact is nugatory...
From @Obsidian_Field_0001_Index_Scaffold_Delta_Intermediate
Where [Order_Beta] = 1

--Harmonise Half Partitions
Declare @Field_0001_Hexadecimal_ID_Hash As Nvarchar(4000)
Set @Field_0001_Hexadecimal_ID_Hash = (Select String_Agg(Cast([Hexadecimal_Character] As Nvarchar(4000)), '') As [Element_Integer_ID_Hash] From @Obsidian_Field_0001_Index_Scaffold_Delta_Final) --Be careful, the hash values are joined in no particular order... This may impact associated development work... If it is causing an issue, you can easily force the order by using the [Order] column which is previously assigned (but commented out as an example) in the @Obsidian_Element_Index_Scaffold_Delta_Final table insert select statement(with the Rown_Number() function), by adding something here with this str_agg function like: Within Group (Order By [Order] Asc) to this line of sourcecode, in the appropriate manner...

--(Integer Field 0002)
--Delta Scaffold Join Hash...
Declare @Obsidian_Field_0002_Index_Scaffold_Delta_Intermediate Table ([Order_Beta] Int, [Index] Nvarchar(4000))
Insert Into @Obsidian_Field_0002_Index_Scaffold_Delta_Intermediate ([Order_Beta], [Index])
Select
	Row_Number() Over(Partition By A.[Index] Order By Crypt_Gen_Random(200) Asc) As [Order_Beta], --This should scramble the index series appropriately, when used in conjunction with storing an order for each scrambled row.
	B.[Index] As [Index] --Could adjust the dynamic function for generating index scaffolds so that we eliminate the minus 1 altogether, but seems unreasonable right now, given the speed impact is nugatory...
From @Obsidian_Index_Scaffold_Alpha A
Cross Join @Obsidian_Index_Scaffold_Beta B

Declare @Obsidian_Field_0002_Index_Scaffold_Delta_Final Table (/*[Order] Int, */[Hexadecimal_Character] Nvarchar(4000))
Insert Into @Obsidian_Field_0002_Index_Scaffold_Delta_Final (/*[Order], */[Hexadecimal_Character])
Select
	--Row_Number() Over(Order By [Configure_Your_Desired_Order_Logic_Here] Asc) As [Order],
	Cast(Replace(Replace(Replace(Replace(Replace(Replace(Cast(([Index] - 1) As Nvarchar(4000)), '10', 'A'), '11', 'B'), '12', 'C'), '13', 'D'), '14', 'E'), '15', 'F') As Nvarchar(4000)) As [Hexadecimal_Character] --Could adjust the dynamic function for generating index scaffolds so that we eliminate the minus 1 altogether, but seems unreasonable right now, given the speed impact is nugatory...
From @Obsidian_Field_0002_Index_Scaffold_Delta_Intermediate
Where [Order_Beta] = 1

--Harmonise Half Partitions
Declare @Field_0002_Hexadecimal_ID_Hash As Nvarchar(4000)
Set @Field_0002_Hexadecimal_ID_Hash = (Select String_Agg(Cast([Hexadecimal_Character] As Nvarchar(4000)), '') As [Element_Integer_ID_Hash] From @Obsidian_Field_0002_Index_Scaffold_Delta_Final) --Be careful, the hash values are joined in no particular order... This may impact associated development work... If it is causing an issue, you can easily force the order by using the [Order] column which is previously assigned (but commented out as an example) in the @Obsidian_Element_Index_Scaffold_Delta_Final table insert select statement(with the Rown_Number() function), by adding something here with this str_agg function like: Within Group (Order By [Order] Asc) to this line of sourcecode, in the appropriate manner...

--(String Field 0003)
--Delta Scaffold Join Hash...
Declare @Obsidian_Field_0003_Index_Scaffold_Delta_Intermediate Table ([Order_Beta] Int, [Index] Nvarchar(4000))
Insert Into @Obsidian_Field_0003_Index_Scaffold_Delta_Intermediate ([Order_Beta], [Index])
Select
	Row_Number() Over(Partition By A.[Index] Order By Crypt_Gen_Random(200) Asc) As [Order_Beta], --This should scramble the index series appropriately, when used in conjunction with storing an order for each scrambled row.
	B.[Index] As [Index] --Could adjust the dynamic function for generating index scaffolds so that we eliminate the minus 1 altogether, but seems unreasonable right now, given the speed impact is nugatory...
From @Obsidian_Index_Scaffold_Alpha A
Cross Join @Obsidian_Index_Scaffold_Beta B

Declare @Obsidian_Field_0003_Index_Scaffold_Delta_Final Table (/*[Order] Int, */[Hexadecimal_Character] Nvarchar(4000))
Insert Into @Obsidian_Field_0003_Index_Scaffold_Delta_Final (/*[Order], */[Hexadecimal_Character])
Select
	--Row_Number() Over(Order By [Configure_Your_Desired_Order_Logic_Here] Asc) As [Order],
	Cast(Replace(Replace(Replace(Replace(Replace(Replace(Cast(([Index] - 1) As Nvarchar(4000)), '10', 'A'), '11', 'B'), '12', 'C'), '13', 'D'), '14', 'E'), '15', 'F') As Nvarchar(4000)) As [Hexadecimal_Character] --Could adjust the dynamic function for generating index scaffolds so that we eliminate the minus 1 altogether, but seems unreasonable right now, given the speed impact is nugatory...
From @Obsidian_Field_0003_Index_Scaffold_Delta_Intermediate
Where [Order_Beta] = 1

--Harmonise Half Partitions
Declare @Field_0003_Hexadecimal_ID_Hash As Nvarchar(4000)
Set @Field_0003_Hexadecimal_ID_Hash = (Select String_Agg(Cast([Hexadecimal_Character] As Nvarchar(4000)), '') As [Element_Integer_ID_Hash] From @Obsidian_Field_0003_Index_Scaffold_Delta_Final) --Be careful, the hash values are joined in no particular order... This may impact associated development work... If it is causing an issue, you can easily force the order by using the [Order] column which is previously assigned (but commented out as an example) in the @Obsidian_Element_Index_Scaffold_Delta_Final table insert select statement(with the Rown_Number() function), by adding something here with this str_agg function like: Within Group (Order By [Order] Asc) to this line of sourcecode, in the appropriate manner...

--(Something Seemingly Banal, Will Probably Turn Out To Be the Critical Algorithmic Facet... No Doubt...)
Declare @Max_Field_cluId As Bigint
Set @Max_Field_cluId = (Select Max([cluId]) From [MooDElementData])

--PLEASE DON'T FORGET TO AMEND THESE INSERTED ROW VALUES BELOW APPROPRIATELY... YOU WILL NEED TO LOOK UP THE [aliasDefFieldId] OR [pickListItemId] FROM THE APPROPRIATE TABLE ([MooDAliasDefField] AND ???[MooDAliasDefSimpleTypePickItem]??? RESPECTIVELY), IN THE MOOD SQL SERVER DATABASE, AND AS SUCH, YOU MUST MAKE SURE THAT YOU PRE-CREATE ALL THE ELEMENTS YOU NEED TO INGEST DATA ONTO... AS WELL AS ANY DESIRED FIELD VALUES IN THEIR RESPECTIVE COLUMNS... OH, AND PLESE DON'T FORGET TO INCREMENT THE CLUID IF YOU ARE SIMULTANEOUSLY INSERTING MULTIPLE FIELD ROWS (HE'S MISBEHAVING ENOUGH ALREADY, I'M SURE YOU'LL AGREE)...
Set Identity_Insert [MooDElementData] ON
Insert Into [MooDElementData] ([className], [id], [subjectId], [subjectType], [aliasDefFieldId], [pickListItemId], [intVal], [boolVal], [dateVal], [realVal], [stringVal], [lastModifiedDateTime], [creationDateTime], [flags], [cluId])
Values
('DTME', @Field_0001_Hexadecimal_ID_Hash, @Element_Hexadecimal_ID_Hash, 55, '03AFE16743A3455812A451C50BFA4E8F', NULL, 0, 0, '2025-03-03 08:01:17.000', 0, NULL, '2025-03-03 08:01:17.000', '2025-03-03 08:01:17.000', 0, (@Max_Field_cluId + 1)),
('INTE', @Field_0002_Hexadecimal_ID_Hash, @Element_Hexadecimal_ID_Hash, 55, '03AFE16743A34558267EA4BF58D44792', NULL, 88888888, 0, NULL, 0, NULL, '2025-03-03 08:01:17.000', '2025-03-03 08:01:17.000', 0, (@Max_Field_cluId + 2)),
('STRN', @Field_0003_Hexadecimal_ID_Hash, @Element_Hexadecimal_ID_Hash, 55, '03AFE16743A3455878F145AD37214F08', NULL, 0, 0, NULL, 0, '88888888', '2025-03-03 08:01:17.000', '2025-03-03 08:01:17.000', 0, (@Max_Field_cluId + 3))
Set Identity_Insert [MooDElementData] OFF

Select 1 --This seems to be necessary for MooD, in order to avoid spurious synchroniser fail messages in the BA audit and validation interface, but also to avoid falsely concerning error messages which would otherwise get displayed to the user via an MAE action (such as clicking a button which executes a custom SQL synchroniser).