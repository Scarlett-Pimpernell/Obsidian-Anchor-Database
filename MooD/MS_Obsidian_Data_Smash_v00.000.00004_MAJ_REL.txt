Select * From [MooDPrimaryElement] Order By [creationDateTime] Desc
Select * From [MooDElementData] Order By [creationDateTime] Desc
Delete From [MooDPrimaryElement] Where [creationDateTime] = '2025-03-03 08:01:17.000'
Delete From [MooDElementData] Where [creationDateTime] = '2025-03-03 08:01:17.000'


--Superfast Obsidian Hexadecimal-Compatible MooD Data Smashing Algorithm (To Be Used In A Custom T-SQL Synchroniser Script)
--Eventually, I plan to amend this approach, so that all the necessary hexadecimal hash IDs can be pre-generated in parallel, before element creation and field data ingestion, as this will provide possibly significant comopute speed improvements.


--(Scaffold)
Declare @Dynamic_SQL_Data_Intermediate_Variable As Nvarchar(Max)
Set @Dynamic_SQL_Data_Intermediate_Variable =
(
'Declare @Number_Seeds Table ([Number_Seed] NvarChar(1))
Insert Into @Number_Seeds ([Number_Seed])
Values (''0''), (''1''), (''2''), (''3''), (''4''), (''5''), (''6''), (''7''), (''8''), (''9'') ' +
Replace(dbo.Obsidian_Element_Index_Generator_Code_Parallel_Super_Fast(32), '@Index_Count', 32) --This algorithm can be found on my GitHub account in the same repository that you found this script in.
)

Declare @Obsidian_Index_Scaffold Table ([Index] Int)
Insert Into @Obsidian_Index_Scaffold ([Index])
Execute (@Dynamic_SQL_Data_Intermediate_Variable)


--(Elements)
Declare @Obsidian_Element_Index_Crypto_Scaffold_Intermediate Table ([Order] Int, [Index] Int)
Insert Into @Obsidian_Element_Index_Crypto_Scaffold_Intermediate ([Order], [Index])
Select
	Row_Number() Over(Order By (Select 1) Asc) As [Order],
	[Index] As [Index]
From @Obsidian_Index_Scaffold
Order By Crypt_Gen_Random(32) --This should scramble the index series appropriately, when used in conjunction with storing an order for each scrambled row.

Declare @Obsidian_Element_Index_Crypto_Scaffold_Final Table ([Index] Nvarchar(4000), [Crypto_Hash] Binary(4000))
Insert Into @Obsidian_Element_Index_Crypto_Scaffold_Final ([Index], [Crypto_Hash])
Select
	(Case When [Order] > 12 Then Cast([Index] As Nvarchar(4000)) Else (Case When [Order] > 0 Or [Order] < 3 Then 'A' Else (Case When [Order] > 2 Or [Order] < 5 Then 'B' Else (Case When [Order] > 4 Or [Order] < 7 Then 'C' Else (Case When [Order] > 6 Or [Order] < 9 Then 'D' Else (Case When [Order] > 8 Or [Order] < 11 Then 'E' Else 'F' End) End) End) End) End) End) As [Index], --This optimally implements a uniform balanced probability hash replace, which makes full use of the unsymmetrical class size value space (as you know, at least in the MooD implementation of hexadecimal IDs, the eventual 32 character ID output string, is composed of numbers 0 to 9 inclusive, and letters A to F inclusive)... Therefore ID clashes will practically be infinitessimalised away, for all itents and purposes. 
	Crypt_Gen_Random(32) As [Crypto_Hash]
From @Obsidian_Element_Index_Crypto_Scaffold_Intermediate

Declare @Element_Hexadecimal_ID_Hash As Nvarchar(4000)
Set @Element_Hexadecimal_ID_Hash = Left(Cast((Select String_Agg([Index], '') Within Group (Order By [Crypto_Hash] Asc) As [Element_Integer_ID_Hash] From @Obsidian_Element_Index_Crypto_Scaffold_Final) As Nvarchar(4000)), 32)

--(Something Seemingly Banal, Will Probably Turn Out To Be the Critical Algorithmic Facet... No Doubt...)
Declare @Max_Element_cluId As Bigint
Set @Max_Element_cluId = (Select Max([cluId]) From [MooDPrimaryElement])

--PLEASE DON'T FORGET TO AMEND THESE INSERTED ROW VALUES BELOW APPROPRIATELY... YOU WILL NEED TO LOOK UP THE [parentId] (IF YOU ARE NOT CREATING THE PARENT ELEMENT HERE ITSELF) ON THE [MooDPrimaryElement] TABLE IN THE MOOD DATABASE; AND THE YOU WILL NEED TO LOOK UP THE [aliasId] FROM THE [MooDAlias] TABLE IN THE MOOD SQL SERVER DATABASE... THE REST OF THE COLUMNS SHOULD BE RATHER SELF-EXPLANATORY IN MY HUMBLE OPINION... (IF YOU ARE CREATING PARENT ELEMENTS {OR EVEN A TREE OF ELEMENTS, THEN MAKE SURE YOU PUT THE HIGHEST LEVEL OF THE TREE TOWARDS THE TOP OF THE INSERT ROWS, AND ORDER THE ROWS SO THAT ALL DESCENDENTS WILL ALWAYS COME AFTER THEIR PARENT ELEMENT ROW... THEN SIMPLY WHILE LOOP AROUND THE INSERT SET OF ROWS, ONE LEVEL OF THE ELEMENT HIERARCHY AT A TIME [SO THAT YOU CAN PRE-GENERATE THE APPROPRIATE HEXADECIMAL IDENTIFIERS]})... OH, AND PLESE DON'T FORGET TO INCREMENT THE CLUID IF YOU ARE SIMULTANEOUSLY INSERTING MULTIPLE ELEMENT ROWS (HE'S MISBEHAVING ENOUGH ALREADY, I'M SURE YOU'LL AGREE)...
Set Identity_Insert [MooDPrimaryElement] ON
Insert Into [MooDPrimaryElement] ([className], [id], [parentId], [aliasId], [ownerId], [name], [variantOfId], [lastModifiedDateTime], [creationDateTime], [flags], [cluId])
Values ('PRIM', @Element_Hexadecimal_ID_Hash, '3708862BD1CD47458E9B65CED5DB79B4', '03AFE16743A3455889C46D09A05D55F1', '786A4991EA7B11D1B4840020AFC894E9', ('Database_Edit_Test_' + Cast(Getdate() As Nvarchar(4000))), NULL, '2025-03-03 08:01:17.000', '2025-03-03 08:01:17.000', 0, (@Max_Element_cluId + 1))
Set Identity_Insert [MooDPrimaryElement] OFF


--THE FOLLOWING DATA FIELD TECHNIQUE MUST BE CARRIED FOR EACH APPROPRIATE FIELD ON A GIVEN PREVIOUSLY CREATED MOOD ELEMENT IN THIS SMASH ALGORITHM, BECAUSE OTHERWISE, THE ELEMENTS MAY BE UNEDITABLE IN MOOD BA AND MOOD MAE!!!... AS SUCH, IF YOU ARE INGESTING A LOT OF FIELD DATA, YOU PROBABLY WANT TO IMPLEMENT THE REST OF THIS ALGORITHM WITHIN A WHILE LOOP, WHICH WOULD LOOP AROUND EACH MOOD ELEMENT FIELD, INSTEAD OF WHAT I HAVE DONE HERE, WHICH IS SIMPLY COPY AND PASTE HAND-CRANKING, BECAUSE I AM APPARENTLY NOT YET RECEIVING PAYMENT FOR MY EFFORTS!!!
--(Datatime Field 0001)
Declare @Obsidian_Field_0001_Index_Crypto_Scaffold_Intermediate Table ([Order] Int, [Index] Int)
Insert Into @Obsidian_Field_0001_Index_Crypto_Scaffold_Intermediate ([Order], [Index])
Select
	Row_Number() Over(Order By (Select 1) Asc) As [Order],
	[Index] As [Index]
From @Obsidian_Index_Scaffold
Order By Crypt_Gen_Random(32) --This should scramble the index series appropriately, when used in conjunction with storing an order for each scrambled row.

Declare @Obsidian_Field_0001_Index_Crypto_Scaffold_Final Table ([Index] Nvarchar(4000), [Crypto_Hash] Binary(4000))
Insert Into @Obsidian_Field_0001_Index_Crypto_Scaffold_Final ([Index], [Crypto_Hash])
Select
	(Case When [Order] > 12 Then Cast([Index] As Nvarchar(4000)) Else (Case When [Order] > 0 Or [Order] < 3 Then 'A' Else (Case When [Order] > 2 Or [Order] < 5 Then 'B' Else (Case When [Order] > 4 Or [Order] < 7 Then 'C' Else (Case When [Order] > 6 Or [Order] < 9 Then 'D' Else (Case When [Order] > 8 Or [Order] < 11 Then 'E' Else 'F' End) End) End) End) End) End) As [Index], --This optimally implements a uniform balanced probability hash replace, which makes full use of the unsymmetrical class size value space (as you know, at least in the MooD implementation of hexadecimal IDs, the eventual 32 character ID output string, is composed of numbers 0 to 9 inclusive, and letters A to F inclusive)... Therefore ID clashes will practically be infinitessimalised away, for all itents and purposes. 
	Crypt_Gen_Random(32) As [Crypto_Hash]
From @Obsidian_Field_0001_Index_Crypto_Scaffold_Intermediate

Declare @Field_0001_Hexadecimal_ID_Hash As Nvarchar(4000)
Set @Field_0001_Hexadecimal_ID_Hash = Left(Cast((Select String_Agg([Index], '') Within Group (Order By [Crypto_Hash] Asc) As [Element_Integer_ID_Hash] From @Obsidian_Field_0001_Index_Crypto_Scaffold_Final) As Nvarchar(4000)), 32)

--(Integer Field 0002)
Declare @Obsidian_Field_0002_Index_Crypto_Scaffold_Intermediate Table ([Order] Int, [Index] Int)
Insert Into @Obsidian_Field_0002_Index_Crypto_Scaffold_Intermediate ([Order], [Index])
Select
	Row_Number() Over(Order By (Select 1) Asc) As [Order],
	[Index] As [Index]
From @Obsidian_Index_Scaffold
Order By Crypt_Gen_Random(32) --This should scramble the index series appropriately, when used in conjunction with storing an order for each scrambled row.

Declare @Obsidian_Field_0002_Index_Crypto_Scaffold_Final Table ([Index] Nvarchar(4000), [Crypto_Hash] Binary(4000))
Insert Into @Obsidian_Field_0002_Index_Crypto_Scaffold_Final ([Index], [Crypto_Hash])
Select
	(Case When [Order] > 12 Then Cast([Index] As Nvarchar(4000)) Else (Case When [Order] > 0 Or [Order] < 3 Then 'A' Else (Case When [Order] > 2 Or [Order] < 5 Then 'B' Else (Case When [Order] > 4 Or [Order] < 7 Then 'C' Else (Case When [Order] > 6 Or [Order] < 9 Then 'D' Else (Case When [Order] > 8 Or [Order] < 11 Then 'E' Else 'F' End) End) End) End) End) End) As [Index], --This optimally implements a uniform balanced probability hash replace, which makes full use of the unsymmetrical class size value space (as you know, at least in the MooD implementation of hexadecimal IDs, the eventual 32 character ID output string, is composed of numbers 0 to 9 inclusive, and letters A to F inclusive)... Therefore ID clashes will practically be infinitessimalised away, for all itents and purposes. 
	Crypt_Gen_Random(32) As [Crypto_Hash]
From @Obsidian_Field_0002_Index_Crypto_Scaffold_Intermediate

Declare @Field_0002_Hexadecimal_ID_Hash As Nvarchar(4000)
Set @Field_0002_Hexadecimal_ID_Hash = Left(Cast((Select String_Agg([Index], '') Within Group (Order By [Crypto_Hash] Asc) As [Element_Integer_ID_Hash] From @Obsidian_Field_0002_Index_Crypto_Scaffold_Final) As Nvarchar(4000)), 32)

--(String Field 0003)
Declare @Obsidian_Field_0003_Index_Crypto_Scaffold_Intermediate Table ([Order] Int, [Index] Int)
Insert Into @Obsidian_Field_0003_Index_Crypto_Scaffold_Intermediate ([Order], [Index])
Select
	Row_Number() Over(Order By (Select 1) Asc) As [Order],
	[Index] As [Index]
From @Obsidian_Index_Scaffold
Order By Crypt_Gen_Random(32) --This should scramble the index series appropriately, when used in conjunction with storing an order for each scrambled row.

Declare @Obsidian_Field_0003_Index_Crypto_Scaffold_Final Table ([Index] Nvarchar(4000), [Crypto_Hash] Binary(4000))
Insert Into @Obsidian_Field_0003_Index_Crypto_Scaffold_Final ([Index], [Crypto_Hash])
Select
	(Case When [Order] > 12 Then Cast([Index] As Nvarchar(4000)) Else (Case When [Order] > 0 Or [Order] < 3 Then 'A' Else (Case When [Order] > 2 Or [Order] < 5 Then 'B' Else (Case When [Order] > 4 Or [Order] < 7 Then 'C' Else (Case When [Order] > 6 Or [Order] < 9 Then 'D' Else (Case When [Order] > 8 Or [Order] < 11 Then 'E' Else 'F' End) End) End) End) End) End) As [Index], --This optimally implements a uniform balanced probability hash replace, which makes full use of the unsymmetrical class size value space (as you know, at least in the MooD implementation of hexadecimal IDs, the eventual 32 character ID output string, is composed of numbers 0 to 9 inclusive, and letters A to F inclusive)... Therefore ID clashes will practically be infinitessimalised away, for all itents and purposes. 
	Crypt_Gen_Random(32) As [Crypto_Hash]
From @Obsidian_Field_0003_Index_Crypto_Scaffold_Intermediate

Declare @Field_0003_Hexadecimal_ID_Hash As Nvarchar(4000)
Set @Field_0003_Hexadecimal_ID_Hash = Left(Cast((Select String_Agg([Index], '') Within Group (Order By [Crypto_Hash] Asc) As [Element_Integer_ID_Hash] From @Obsidian_Field_0003_Index_Crypto_Scaffold_Final) As Nvarchar(4000)), 32)

--(Something Seemingly Banal, Will Probably Turn Out To Be the Critical Algorithmic Facet... No Doubt...)
Declare @Max_Field_cluId As Bigint
Set @Max_Field_cluId = (Select Max([cluId]) From [MooDElementData])

--PLEASE DON'T FORGET TO AMEND THESE INSERTED ROW VALUES BELOW APPROPRIATELY... YOU WILL NEED TO LOOK UP THE [aliasDefFieldId] OR [pickListItemId] FROM THE APPROPRIATE TABLE ([MooDAliasDefField] AND ???[MooDAliasDefSimpleTypePickItem]??? RESPECTIVELY), IN THE MOOD SQL SERVER DATABASE, AND AS SUCH, YOU MUST MAKE SURE THAT YOU PRE-CREATE ALL THE ELEMENTS YOU NEED TO INGEST DATA ONTO... AS WELL AS ANY DESIRED FIELD VALUES IN THEIR RESPECTIVE COLUMNS... OH, AND PLESE DON'T FORGET TO INCREMENT THE CLUID IF YOU ARE SIMULTANEOUSLY INSERTING MULTIPLE FIELD ROWS (HE'S MISBEHAVING ENOUGH ALREADY, I'M SURE YOU'LL AGREE)...
Set Identity_Insert [MooDElementData] ON
Insert Into [MooDElementData] ([className], [id], [subjectId], [subjectType], [aliasDefFieldId], [pickListItemId], [intVal], [boolVal], [dateVal], [realVal], [stringVal], [lastModifiedDateTime], [creationDateTime], [flags], [cluId])
Values
('DTME', @Field_0001_Hexadecimal_ID_Hash, @Element_Hexadecimal_ID_Hash, 55, '03AFE16743A3455812A451C50BFA4E8F', NULL, 0, 0, '2025-03-03 08:01:17.000', 0, NULL, '2025-03-03 08:01:17.000', '2025-03-03 08:01:17.000', 0, (@Max_Field_cluId + 1)),
('INTE', @Field_0002_Hexadecimal_ID_Hash, @Element_Hexadecimal_ID_Hash, 55, '03AFE16743A34558267EA4BF58D44792', NULL, 88888888, 0, NULL, 0, NULL, '2025-03-03 08:01:17.000', '2025-03-03 08:01:17.000', 0, (@Max_Field_cluId + 2)),
('STRN', @Field_0003_Hexadecimal_ID_Hash, @Element_Hexadecimal_ID_Hash, 55, '03AFE16743A3455878F145AD37214F08', NULL, 0, 0, NULL, 0, '88888888', '2025-03-03 08:01:17.000', '2025-03-03 08:01:17.000', 0, (@Max_Field_cluId + 3))
Set Identity_Insert [MooDElementData] OFF

Select 1 --This seems to be necessary for MooD, in order to avoid spurious synchroniser fail messages in the BA audit and validation interface, but also to avoid falsely concerning error messages which would otherwise get displayed to the user via an MAE action (such as clicking a button which executes a custom SQL synchroniser).