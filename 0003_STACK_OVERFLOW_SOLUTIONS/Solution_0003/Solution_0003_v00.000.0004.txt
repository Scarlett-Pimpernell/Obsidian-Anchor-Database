-----Intrinsic SQL Server System Constants
/*
Declare @Datetime2_Range_Start_Date As Date
Set @Datetime2_Range_Start_Date = '0001-01-01'
Declare @Datetime2_Range_Start_Index As Varchar(100)
Set @Datetime2_Range_Start_Index = Cast(Format(@Datetime2_Range_Start_Date, 'yyyyMMddHHmmss.fffffff') As Varchar(100))
Declare @Datetime2_Range_End_Date As Date
Set @Datetime2_Range_End_Date = '9999-12-31'
Declare @Datetime2_Range_End_Index As Varchar(100)
Set @Datetime2_Range_End_Index = Cast(Format(@Datetime2_Range_End_Date, 'yyyyMMddHHmmss.fffffff') As Varchar(100))
Declare @Datetime2_Index_Range As Decimal(38, 19)
Set @Datetime2_Index_Range = (Cast(@Datetime2_Range_End_Index As Decimal(38, 19)) - Cast(@Datetime2_Range_Start_Index As Decimal(38, 19)))
*/

Declare @Days_Of_the_Month Table ([Month] Varchar(100), [Normal_Days] Varchar(100), [Leap_Days] Varchar(100)) --Gregorian calendar
Insert Into @Days_Of_the_Month
Values --Please be aware that the [Month] column values must have padded zeroes to two digit places... For example 01 instead of 1... This is because we pad later on, in order to form proper date values...
('01', '31', '31'),
('02', '28', '29'), --Notice the different normal and leap values for month 2, in order to handle leap year in later logic in this algorithm...
('03', '31', '31'),
('04', '30', '30'),
('05', '31', '31'),
('06', '30', '30'),
('07', '31', '31'),
('08', '31', '31'),
('09', '30', '30'),
('10', '31', '31'),
('11', '30', '30'),
('12', '31', '31')
-----Intrinsic SQL Server System Constants


--GLOBAL VARIABLES
Declare @Seed_Year_Start_Date As Date
Set @Seed_Year_Start_Date = '2023-01-01' --This needs to be a seed year start date which is before, or on, your earliest input data [BusinessDate]...

Declare @Seed_YearLeading_Limit_Week_Start_Day_Of_the_Week_Index As Tinyint
Set @Seed_YearLeading_Limit_Week_Start_Day_Of_the_Week_Index = 7 --That is, Sunday in the seed year 2023 (the 7th day of this usecase's Monday to Sunday weekly structure)... Only change this, depending on the seed year start date for your usecase...

Declare @Week_Type_Day_Of_the_Week_Index As Varchar(7)
Set @Week_Type_Day_Of_the_Week_Index = 1 --Assigning this variable a value of one (1), causes the algorithm to behave as if Monday was the first of the week... Any integer between 1 (inclusive) and 7 (inclusive), can be used, corresponding to the day indexes of the week... A value of seven (7) would set Sunday as the first of the week, for example...


--INPUT DATA
Declare @BusinessInformation Table ([BusinessDate] Date)
Insert Into @BusinessInformation
Values
('2024-02-16'),
('2024-02-17'),
('2024-02-18'),
('2024-02-19'),
('2024-02-20'),
('2024-02-21'),
('2024-02-22'),
('2024-02-23'),
('2024-02-24'),
('2024-02-25'),
('2024-02-26'),
('2024-01-01'),
('2024-01-02'),
('2024-12-30'),
('2024-12-31'),
('2025-01-01'),
('2025-01-02')


--ALGORITHM EXECUTION
Declare @BusinessInformation_Ordered Table ([Order] Bigint, [BusinessDate] Date)
Insert Into @BusinessInformation_Ordered
Select
	Row_Number() Over (Order By (Select Null)) As [Order], --We need to add an order column, in order to retain duplicate Business Dates... Although this may not be the behaviour you desire, in which case you can skip this step, and amend the following code appropriately, to ignor grouping by [Order] column...
	[BusinessDate] As [BusinessDate]
From @BusinessInformation

Select
	Min(A.[BusinessDate]) AS [WeekNumberOfYear],
	Cast((Case When Min(B.[Month]) Is Null Then Cast(1 As Decimal(38,19)) Else (Cast(Substring(Cast(A.[BusinessDate] As Varchar(Max)), 9, 2) As Decimal(38,19)) + Sum((Case When Cast(Substring(Cast(A.[BusinessDate] As Varchar(Max)), 1, 4) As Decimal(38,19)) % 400 = 0 Then Cast(B.[Leap_Days] As Decimal(38,19)) Else (Case When Cast(Substring(Cast(A.[BusinessDate] As Varchar(Max)), 1, 4) As Decimal(38,19)) % 100 = 0 Then Cast(B.[Normal_Days] As Decimal(38,19)) Else (Case When Cast(Substring(Cast(A.[BusinessDate] As Varchar(Max)), 1, 4) As Decimal(38,19)) % 4 = 0 Then Cast(B.[Leap_Days] As Decimal(38,19)) Else Cast(B.[Normal_Days] As Decimal(38,19)) End) End) End))) End) As Bigint) As [Previous_Days_Count_Since_Seed_Year_Start_Date], --Please know that HERE WE HANDLE LEAP YEARS AUTOMATICALLY...
	(Case When Min(B.[Month]) Is Null Then Ceiling((Cast(Substring(Cast(A.[BusinessDate] As Varchar(Max)), 9, 2) As Decimal(38,19)) / Cast(7 As Decimal(38,19)))) Else Floor(((Cast(Substring(Cast(A.[BusinessDate] As Varchar(Max)), 9, 2) As Decimal(38,19)) + Sum((Case When Cast(Substring(Cast(A.[BusinessDate] As Varchar(Max)), 1, 4) As Decimal(38,19)) % 400 = 0 Then Cast(B.[Leap_Days] As Decimal(38,19)) Else (Case When Cast(Substring(Cast(A.[BusinessDate] As Varchar(Max)), 1, 4) As Decimal(38,19)) % 100 = 0 Then Cast(B.[Normal_Days] As Decimal(38,19)) Else (Case When Cast(Substring(Cast(A.[BusinessDate] As Varchar(Max)), 1, 4) As Decimal(38,19)) % 4 = 0 Then Cast(B.[Leap_Days] As Decimal(38,19)) Else Cast(B.[Normal_Days] As Decimal(38,19)) End) End) End))) / Cast(7 As Decimal(38,19)))) End) As [WeekNumberOfYear]
From @BusinessInformation_Ordered A
Left Join @Days_Of_the_Month B On
	(Cast(B.[Month] As Bigint) < Cast(Substring(Cast(A.[BusinessDate] As Varchar(Max)), 6, 2) As Bigint))
Group By A.[Order], A.[BusinessDate]


--Still need to handle multi-year spans!!!