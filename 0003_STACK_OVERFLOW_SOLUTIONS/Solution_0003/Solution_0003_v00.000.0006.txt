--COMMENTS
--This algorithm automatically handles both week system starting day of the week logic (which makes partial week spans possible, as well as therefore, the 53rd week of the year also sometimes possible), and leap year logic (which makes the 54th week of the year rarely possible during leap years)...


-----Intrinsic SQL Server System Constants
/*
Declare @Datetime2_Range_Start_Date As Date
Set @Datetime2_Range_Start_Date = '0001-01-01'
Declare @Datetime2_Range_Start_Index As Varchar(100)
Set @Datetime2_Range_Start_Index = Cast(Format(@Datetime2_Range_Start_Date, 'yyyyMMddHHmmss.fffffff') As Varchar(100))
Declare @Datetime2_Range_End_Date As Date
Set @Datetime2_Range_End_Date = '9999-12-31'
Declare @Datetime2_Range_End_Index As Varchar(100)
Set @Datetime2_Range_End_Index = Cast(Format(@Datetime2_Range_End_Date, 'yyyyMMddHHmmss.fffffff') As Varchar(100))
Declare @Datetime2_Index_Range As Decimal(38, 19)
Set @Datetime2_Index_Range = (Cast(@Datetime2_Range_End_Index As Decimal(38, 19)) - Cast(@Datetime2_Range_Start_Index As Decimal(38, 19)))
*/

Declare @Days_Of_the_Month Table ([Month] Varchar(100), [Normal_Days] Varchar(100), [Leap_Days] Varchar(100)) --Gregorian calendar
Insert Into @Days_Of_the_Month
Values --Please be aware that the [Month] column values must have padded zeroes to two digit places... For example 01 instead of 1... This is because we pad later on, in order to form proper date values...
('01', '31', '31'),
('02', '28', '29'), --Notice the different normal and leap values for month 2, in order to handle leap year in later logic in this algorithm...
('03', '31', '31'),
('04', '30', '30'),
('05', '31', '31'),
('06', '30', '30'),
('07', '31', '31'),
('08', '31', '31'),
('09', '30', '30'),
('10', '31', '31'),
('11', '30', '30'),
('12', '31', '31')
-----Intrinsic SQL Server System Constants


--GLOBAL VARIABLES
Declare @Week_System_First_Day_Of_the_Week_Index As Tinyint
Set @Week_System_First_Day_Of_the_Week_Index = 1 --Assigning this variable a value of one (1), causes the algorithm to behave as if Monday was the first day of the week... Any integer between 1 (inclusive) and 7 (inclusive), can be used, corresponding to the day indexes of the week... A value of seven (7) would set Sunday as the first of the week, for example...


--INPUT DATA
Declare @BusinessInformation Table ([BusinessDate] Date)
Insert Into @BusinessInformation
Values
('2024-02-16'),
('2024-02-17'),
('2024-02-18'),
('2024-02-19'),
('2024-02-20'),
('2024-02-21'),
('2024-02-22'),
('2024-02-23'),
('2024-02-24'),
('2024-02-25'),
('2024-02-26'),
('2024-01-01'),
('2024-01-02'),
('2024-12-30'),
('2024-12-31'),
('2025-01-01'),
('2025-01-02')


--ALGORITHM EXECUTION
Declare @BusinessInformation_Ordered Table ([Order] Bigint, [BusinessDate] Date)
Insert Into @BusinessInformation_Ordered
Select
	Row_Number() Over (Order By (Select Null)) As [Order], --We need to add an order column, in order to retain duplicate Business Dates... Although this may not be the behaviour you desire, in which case you can skip this step, and amend the following code appropriately, to ignor grouping by [Order] column...
	[BusinessDate] As [BusinessDate]
From @BusinessInformation

Declare @Week_System_Offset As Tinyint
Set @Week_System_Offset = (7 - @Week_System_First_Day_Of_the_Week_Index)

Select
	Min(A.[BusinessDate]) AS [WeekNumberOfYear],
	--Cast((Case When Min(B.[Month]) Is Null Then Cast(1 As Decimal(38,19)) Else (Cast(Substring(Cast(A.[BusinessDate] As Varchar(Max)), 9, 2) As Decimal(38,19)) + Sum((Case When Cast(Substring(Cast(A.[BusinessDate] As Varchar(Max)), 1, 4) As Decimal(38,19)) % 400 = 0 Then Cast(B.[Leap_Days] As Decimal(38,19)) Else (Case When Cast(Substring(Cast(A.[BusinessDate] As Varchar(Max)), 1, 4) As Decimal(38,19)) % 100 = 0 Then Cast(B.[Normal_Days] As Decimal(38,19)) Else (Case When Cast(Substring(Cast(A.[BusinessDate] As Varchar(Max)), 1, 4) As Decimal(38,19)) % 4 = 0 Then Cast(B.[Leap_Days] As Decimal(38,19)) Else Cast(B.[Normal_Days] As Decimal(38,19)) End) End) End))) End) As Bigint) As [Previous_Days_Count_In_Previous_Months_Since_the_Start_Of_the_Year],
	Ceiling((Case When Min(B.[Month]) Is Null Then ((Cast(Substring(Cast(A.[BusinessDate] As Varchar(Max)), 9, 2) As Decimal(38,19)) + Cast(@Week_System_Offset As Decimal(38,19))) / Cast(7 As Decimal(38,19))) Else (((Cast(Substring(Cast(A.[BusinessDate] As Varchar(Max)), 9, 2) As Decimal(38,19)) + Cast(@Week_System_Offset As Decimal(38,19))) + Sum((Case When Cast(Substring(Cast(A.[BusinessDate] As Varchar(Max)), 1, 4) As Decimal(38,19)) % 400 = 0 Then Cast(B.[Leap_Days] As Decimal(38,19)) Else (Case When Cast(Substring(Cast(A.[BusinessDate] As Varchar(Max)), 1, 4) As Decimal(38,19)) % 100 = 0 Then Cast(B.[Normal_Days] As Decimal(38,19)) Else (Case When Cast(Substring(Cast(A.[BusinessDate] As Varchar(Max)), 1, 4) As Decimal(38,19)) % 4 = 0 Then Cast(B.[Leap_Days] As Decimal(38,19)) Else Cast(B.[Normal_Days] As Decimal(38,19)) End) End) End))) / Cast(7 As Decimal(38,19))) End)) As [WeekNumberOfYear]--,
	--Datepart(wk, [BusinessDate]) As [Standard_SQL_Server_WeekNumberOfYear_For_Comparison]
From @BusinessInformation_Ordered A
Left Join @Days_Of_the_Month B On
	(Cast(B.[Month] As Bigint) < Cast(Substring(Cast(A.[BusinessDate] As Varchar(Max)), 6, 2) As Bigint))
Group By A.[Order], A.[BusinessDate]

 --Please remember that the 53rd week and even the 54th week of the year are possible... See the comments at the start of this query for a short explanation...