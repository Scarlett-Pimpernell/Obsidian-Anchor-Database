-----Intrinsic SQL Server System Constants
/*
Declare @Datetime2_Range_Start_Date As Date
Set @Datetime2_Range_Start_Date = '0001-01-01'
Declare @Datetime2_Range_Start_Index As Varchar(100)
Set @Datetime2_Range_Start_Index = Cast(Format(@Datetime2_Range_Start_Date, 'yyyyMMddHHmmss.fffffff') As Varchar(100))
Declare @Datetime2_Range_End_Date As Date
Set @Datetime2_Range_End_Date = '9999-12-31'
Declare @Datetime2_Range_End_Index As Varchar(100)
Set @Datetime2_Range_End_Index = Cast(Format(@Datetime2_Range_End_Date, 'yyyyMMddHHmmss.fffffff') As Varchar(100))
Declare @Datetime2_Index_Range As Decimal(38, 19)
Set @Datetime2_Index_Range = (Cast(@Datetime2_Range_End_Index As Decimal(38, 19)) - Cast(@Datetime2_Range_Start_Index As Decimal(38, 19)))
*/

Declare @Days_Of_the_Month Table ([Month] Varchar(100), [Normal_Days] Varchar(100), [Leap_Days] Varchar(100)) --Gregorian calendar
Insert Into @Days_Of_the_Month
Values --Please be aware that the [Month] column values must have padded zeroes to two digit places... For example 01 instead of 1... This is because we pad later on, in order to form proper date values...
('01', '31', '31'),
('02', '28', '29'), --Notice the different normal and leap values for month 2, in order to handle leap year in later logic in this algorithm...
('03', '31', '31'),
('04', '30', '30'),
('05', '31', '31'),
('06', '30', '30'),
('07', '31', '31'),
('08', '31', '31'),
('09', '30', '30'),
('10', '31', '31'),
('11', '30', '30'),
('12', '31', '31')
-----Intrinsic SQL Server System Constants


--GLOBAL VARIABLES
Declare @Seed_Year_Start_Date As Date
Set @Seed_Year_Start_Date = '2023-01-01' --This needs to be a seed year start date which is before, or on, your earliest input data [BusinessDate]...

Declare @Leading_Limit_Week_Start_Day_Of_the_Week_Index As Tinyint
Set @Leading_Limit_Week_Start_Day_Of_the_Week_Index = 7 --That is, Sunday (the 7th day of your Monday to Sunday weekly structure)... Only change this, depending on the seed year start date for your usecase...

Declare @Leading_Limit_Week_Type As Varchar(7)
Set @Leading_Limit_Week_Type = 'Partial' --As opposed to the other variable assignation value option: 'Full'...


--INPUT DATA
Declare @BusinessInformation Table ([BusinessDate] Date)
Insert Into @BusinessInformation
Values
('2024-02-16'),
('2024-02-17'),
('2024-02-18'),
('2024-02-19'),
('2024-02-20'),
('2024-02-21'),
('2024-02-22'),
('2024-02-23'),
('2024-02-24'),
('2024-02-25'),
('2024-02-26'),
('2024-01-01'),
('2024-01-02'),
('2024-12-30'),
('2024-12-31'),
('2025-01-01'),
('2025-01-02')


--ALGORITHM EXECUTION
Declare @BusinessInformation_Ordered Table ([Order] Bigint, [BusinessDate] Date)
Insert Into @BusinessInformation_Ordered
Select
	Row_Number() Over (Order By (Select Null)) As [Order], --We need to add an order column, in order to retain duplicate Business Dates... Although this may not be the behaviour you desire, in which case you can skip this step, and amend the following code appropriately, to ignor grouping by [Order] column...
	[BusinessDate] As [BusinessDate]
From @BusinessInformation

Select
	Min(A.[BusinessDate]) AS [WeekNumberOfYear],
	(Cast(Substring(Cast(A.[BusinessDate] As Varchar(Max)), 9, 2) As Bigint) + Sum((Case When Cast(Substring(Cast(A.[BusinessDate] As Varchar(Max)), 1, 4) As Bigint) % 400 = 0 Then Cast(B.[Leap_Days] As Bigint) Else (Case When Cast(Substring(Cast(A.[BusinessDate] As Varchar(Max)), 1, 4) As Bigint) % 100 = 0 Then Cast(B.[Normal_Days] As Bigint) Else (Case When Cast(Substring(Cast(A.[BusinessDate] As Varchar(Max)), 1, 4) As Bigint) % 4 = 0 Then Cast(B.[Leap_Days] As Bigint) Else Cast(B.[Normal_Days] As Bigint) End) End) End))) As [Previous_Days_Count_Since_Seed_Year_Start_Date], --Please know that HERE WE HANDLE LEAP YEARS AUTOMATICALLY...
	1 As [WeekNumberOfYear]
From @BusinessInformation_Ordered A
Inner Join @Days_Of_the_Month B On
	(Cast(B.[Month] As Bigint) < Cast(Substring(Cast(A.[BusinessDate] As Varchar(Max)), 6, 2) As Bigint))
Group By A.[Order], A.[BusinessDate]


--Still need to handle multi-year spans!!!